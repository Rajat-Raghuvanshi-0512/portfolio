"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cancelUpload = cancelUpload;
exports.getUpload = getUpload;
exports.uploadFile = uploadFile;
exports.uploadUrl = uploadUrl;
var _uuid = require("@sanity/uuid");
var _lodash = require("lodash");
var _rxjs = require("rxjs");
var _operators = require("rxjs/operators");
var _SanityClient = _interopRequireDefault(require("../clients/SanityClient"));
var _upChunkObservable = require("../clients/upChunkObservable");
var _config = _interopRequireDefault(require("../config"));
var _assets = require("./assets");
var _secrets = require("./secrets");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function cancelUpload(uuid) {
  return _SanityClient.default.observable.request({
    url: "/addons/mux/uploads/".concat(_SanityClient.default.clientConfig.dataset, "/").concat(uuid),
    withCredentials: true,
    method: 'DELETE'
  });
}
function uploadUrl(url) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return testUrl(url).pipe((0, _operators.switchMap)(validUrl => {
    return (0, _rxjs.concat)((0, _rxjs.of)({
      type: 'url',
      url: validUrl
    }), (0, _secrets.testSecretsObservable)().pipe((0, _operators.switchMap)(json => {
      if (!json || !json.status) {
        return (0, _rxjs.throwError)(new Error('Invalid credentials'));
      }
      var uuid = (0, _uuid.uuid)();
      var enableSignedUrls = options.enableSignedUrls;
      var muxBody = {
        input: validUrl,
        playback_policy: [enableSignedUrls ? 'signed' : 'public'],
        mp4_support: _config.default.mp4_support
      };
      var query = {
        muxBody: JSON.stringify(muxBody),
        filename: validUrl.split('/').slice(-1)[0]
      };
      var dataset = _SanityClient.default.clientConfig.dataset;
      return (0, _rxjs.defer)(() => _SanityClient.default.observable.request({
        url: "/addons/mux/assets/".concat(dataset),
        withCredentials: true,
        method: 'POST',
        headers: {
          'MUX-Proxy-UUID': uuid,
          'Content-Type': 'application/json'
        },
        query
      })).pipe((0, _operators.mergeMap)(result => {
        var asset = result && result.results && result.results[0] && result.results[0].document || null;
        if (!asset) {
          return (0, _rxjs.throwError)(new Error('No asset document returned'));
        }
        return (0, _rxjs.of)({
          type: 'success',
          id: uuid,
          asset
        });
      }));
    })));
  }));
}
function uploadFile(file) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return testFile(file).pipe((0, _operators.switchMap)(fileOptions => {
    return (0, _rxjs.concat)((0, _rxjs.of)({
      type: 'file',
      file: fileOptions
    }), (0, _secrets.testSecretsObservable)().pipe((0, _operators.switchMap)(json => {
      if (!json || !json.status) {
        return (0, _rxjs.throwError)(new Error('Invalid credentials'));
      }
      var uuid = (0, _uuid.uuid)();
      var enableSignedUrls = options.enableSignedUrls;
      var body = {
        mp4_support: _config.default.mp4_support,
        playback_policy: [enableSignedUrls ? 'signed' : 'public']
      };
      return (0, _rxjs.concat)((0, _rxjs.of)({
        type: 'uuid',
        uuid
      }), (0, _rxjs.defer)(() => _SanityClient.default.observable.request({
        url: "/addons/mux/uploads/".concat(_SanityClient.default.clientConfig.dataset),
        withCredentials: true,
        method: 'POST',
        headers: {
          'MUX-Proxy-UUID': uuid,
          'Content-Type': 'application/json'
        },
        body
      })).pipe((0, _operators.mergeMap)(result => {
        return (0, _upChunkObservable.createUpChunkObservable)(uuid, result.upload.url, file).pipe(
        // eslint-disable-next-line no-warning-comments
        // @TODO type the observable events
        // eslint-disable-next-line max-nested-callbacks
        (0, _operators.mergeMap)(event => {
          if (event.type !== 'success') {
            return (0, _rxjs.of)(event);
          }
          return (0, _rxjs.from)(updateAssetDocumentFromUpload(uuid)).pipe(
          // eslint-disable-next-line max-nested-callbacks
          (0, _operators.mergeMap)(doc => (0, _rxjs.of)(_objectSpread(_objectSpread({}, event), {}, {
            asset: doc
          }))));
        }),
        // eslint-disable-next-line max-nested-callbacks
        (0, _operators.catchError)(err => {
          // Delete asset document
          return cancelUpload(uuid).pipe((0, _operators.mergeMapTo)((0, _rxjs.throwError)(err)));
        }));
      })));
    })));
  }));
}
function getUpload(assetId) {
  return _SanityClient.default.request({
    url: "/addons/mux/uploads/".concat(_SanityClient.default.clientConfig.dataset, "/").concat(assetId),
    withCredentials: true,
    method: 'GET'
  });
}
function pollUpload(uuid) {
  var maxTries = 10;
  var pollInterval;
  var tries = 0;
  var assetId;
  var upload;
  return new Promise((resolve, reject) => {
    pollInterval = setInterval( /*#__PURE__*/_asyncToGenerator(function* () {
      try {
        upload = yield getUpload(uuid);
      } catch (err) {
        reject(err);
        return;
      }
      assetId = upload && upload.data && upload.data.asset_id;
      if (assetId) {
        clearInterval(pollInterval);
        resolve(upload);
      }
      if (tries > maxTries) {
        clearInterval(pollInterval);
        reject(new Error('Upload did not finish'));
      }
      tries++;
    }), 2000);
  });
}
function updateAssetDocumentFromUpload(_x) {
  return _updateAssetDocumentFromUpload.apply(this, arguments);
}
function _updateAssetDocumentFromUpload() {
  _updateAssetDocumentFromUpload = _asyncToGenerator(function* (uuid) {
    var upload;
    var asset;
    try {
      upload = yield pollUpload(uuid);
    } catch (err) {
      return Promise.reject(err);
    }
    try {
      asset = yield (0, _assets.getAsset)(upload.data.asset_id);
    } catch (err) {
      return Promise.reject(err);
    }
    var doc = {
      _id: uuid,
      _type: 'mux.videoAsset',
      status: asset.data.status,
      data: asset.data,
      assetId: asset.data.id,
      playbackId: asset.data.playback_ids[0].id,
      uploadId: upload.data.id
    };
    return _SanityClient.default.createOrReplace(doc).then(() => {
      return doc;
    });
  });
  return _updateAssetDocumentFromUpload.apply(this, arguments);
}
function testFile(file) {
  if (typeof window !== 'undefined' && file instanceof window.File) {
    var fileOptions = optionsFromFile({}, file);
    return (0, _rxjs.of)(fileOptions);
  }
  return (0, _rxjs.throwError)(new Error('Invalid file'));
}
function testUrl(url) {
  var error = new Error('Invalid URL');
  if (!(0, _lodash.isString)(url)) {
    return (0, _rxjs.throwError)(error);
  }
  var parsed;
  try {
    parsed = new URL(url);
  } catch (err) {
    return (0, _rxjs.throwError)(error);
  }
  if (parsed && !parsed.protocol.match(/http:|https:/)) {
    return (0, _rxjs.throwError)(error);
  }
  return (0, _rxjs.of)(url);
}
function optionsFromFile(opts, file) {
  if (typeof window === 'undefined' || !(file instanceof window.File)) {
    return opts;
  }
  return {
    name: opts.preserveFilename === false ? undefined : file.name,
    type: file.type
  };
}
//# sourceMappingURL=upload.js.map