"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createSigningKeys = createSigningKeys;
exports.fetchSecrets = fetchSecrets;
exports.haveValidSigningKeys = haveValidSigningKeys;
exports.saveSecrets = saveSecrets;
exports.testSecrets = testSecrets;
exports.testSecretsObservable = testSecretsObservable;
var _rxjs = require("rxjs");
var _SanityClient = _interopRequireDefault(require("../clients/SanityClient"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var cache = {
  secrets: null,
  exists: false
};
function fetchSecrets() {
  if (cache.exists) {
    return Promise.resolve(cache);
  }
  return _SanityClient.default.fetch('*[_id == "secrets.mux"][0]').then(secrets => {
    cache.exists = Boolean(secrets);
    cache.secrets = {
      token: (secrets === null || secrets === void 0 ? void 0 : secrets.token) || null,
      secretKey: (secrets === null || secrets === void 0 ? void 0 : secrets.secretKey) || null,
      enableSignedUrls: (secrets === null || secrets === void 0 ? void 0 : secrets.enableSignedUrls) || false,
      signingKeyId: (secrets === null || secrets === void 0 ? void 0 : secrets.signingKeyId) || null,
      signingKeyPrivate: (secrets === null || secrets === void 0 ? void 0 : secrets.signingKeyPrivate) || null
    };
    return cache;
  });
}
function saveSecrets(token, secretKey, enableSignedUrls, signingKeyId, signingKeyPrivate) {
  var doc = {
    _id: 'secrets.mux',
    _type: 'mux.apiKey',
    token,
    secretKey,
    enableSignedUrls,
    signingKeyId,
    signingKeyPrivate
  };
  return _SanityClient.default.createOrReplace(doc).then(() => {
    cache.exists = true;
    cache.secrets = {
      token,
      secretKey,
      enableSignedUrls,
      signingKeyId,
      signingKeyPrivate
    };
    return cache.secrets;
  });
}
function createSigningKeys() {
  var dataset = _SanityClient.default.clientConfig.dataset;
  return _SanityClient.default.request({
    url: "/addons/mux/signing-keys/".concat(dataset),
    withCredentials: true,
    method: 'POST'
  });
}
function testSecrets() {
  var dataset = _SanityClient.default.clientConfig.dataset;
  return _SanityClient.default.request({
    url: "/addons/mux/secrets/".concat(dataset, "/test"),
    withCredentials: true,
    method: 'GET'
  });
}
function haveValidSigningKeys(_x, _x2) {
  return _haveValidSigningKeys.apply(this, arguments);
}
function _haveValidSigningKeys() {
  _haveValidSigningKeys = _asyncToGenerator(function* (signingKeyId, signingKeyPrivate) {
    if (!(signingKeyId && signingKeyPrivate)) {
      return false;
    }
    var dataset = _SanityClient.default.clientConfig.dataset;
    try {
      var res = yield _SanityClient.default.request({
        url: "/addons/mux/signing-keys/".concat(dataset, "/").concat(signingKeyId),
        withCredentials: true,
        method: 'GET'
      });
      //
      // if this signing key is valid it will return { data: { id: 'xxxx' } }
      //
      return !!(res.data && res.data.id);
    } catch (e) {
      console.error('Error fetching signingKeyId', signingKeyId, 'assuming it is not valid');
      return false;
    }
  });
  return _haveValidSigningKeys.apply(this, arguments);
}
function testSecretsObservable() {
  var dataset = _SanityClient.default.clientConfig.dataset;
  return (0, _rxjs.defer)(() => _SanityClient.default.observable.request({
    url: "/addons/mux/secrets/".concat(dataset, "/test"),
    withCredentials: true,
    method: 'GET'
  }));
}
//# sourceMappingURL=secrets.js.map